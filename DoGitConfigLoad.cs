using System;
using System.IO;
using Newtonsoft.Json;

namespace BranchReload2
{
    public class DoGitConfigLoad
    {
        
        public GitFileConfigs GitFileConfigs { get; set; }
        
        public void SetupConfigItems()
        {
            string file_name = "./externalbranch_config.json";
            if (!File.Exists(file_name))
            {
                GitFileConfigs GFC = new(){Key = ""};
                //if the file doesn't exist, it will to set to a blank JSON of the GitFileConfigs instance.
                File.WriteAllText(file_name, JsonConvert.SerializeObject(GFC));
            }
            
            GitFileConfigs RetrievedConfigs = JsonConvert.DeserializeObject<GitFileConfigs>(File.ReadAllText(file_name));

            if (RetrievedConfigs.EmptyValue(RetrievedConfigs.BranchId))
            {
                RetrievedConfigs.BranchId = Guid.NewGuid().ToString().Replace("-","_");
            }
            
            if (RetrievedConfigs.KeyHashIsValid())
            {
                Console.WriteLine($"Existing Key value {RetrievedConfigs.Key} was generated by this program (or one using the same method to setup the string)");
            }
            
            if (HasValidConfigContent(RetrievedConfigs))
            {
                Console.WriteLine($"Existing key manually entered: {RetrievedConfigs.Key} {RetrievedConfigs.GetHash()}");
                if (!RetrievedConfigs.KeyHashIsValid())
                {
                    SetAccessTokenAsEnvironmentVariable(RetrievedConfigs.Key);
                    RetrievedConfigs.Key = RetrievedConfigs.GetHash();
                }
                File.WriteAllText(file_name, JsonConvert.SerializeObject(RetrievedConfigs));
            }
            else
            {
                throw new ("Config file has missing entries.");
            }

            GitFileConfigs = RetrievedConfigs;
        }

        public bool HasValidConfigContent(GitFileConfigs configs)
        {
            return configs.HasValidEntries() && !configs.KeyIsUnset();
        }

        public void SetAccessTokenAsEnvironmentVariable(string access_key)
        {
            Console.WriteLine($"STORING: {access_key}");
            Console.WriteLine(">>"+Environment.GetEnvironmentVariable(EnvironmentWriter.AccessTokenTarget, EnvironmentVariableTarget.User));
            Environment.SetEnvironmentVariable(EnvironmentWriter.AccessTokenTarget, access_key, EnvironmentVariableTarget.User);
        }
    }
}